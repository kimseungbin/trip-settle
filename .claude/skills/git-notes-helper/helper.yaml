name: git-notes-helper
description: |
  Reusable utilities for working with git notes in CI/CD workflows.

  Provides common operations for:
  - Fetching git notes from remote
  - Reading notes from commits
  - Parsing INI-format note data
  - Historical analysis across commits
  - Writing notes in CI (post-job architecture pattern)

  This skill is used by other skills (docker-cache-analysis, e2e-failure-analysis)
  that store structured metadata in git notes.

instructions: |
  This skill provides reusable git notes utilities. It is typically used by other skills,
  not invoked directly by users.

  ## Background: What Are Git Notes?

  Git notes are metadata attached to commits without changing commit history:

  - **Stored separately**: Notes live in refs/notes/* namespace
  - **Not fetched by default**: Require explicit fetch
  - **Pushed independently**: Can be updated without changing commits
  - **Perfect for CI metadata**: Store test results, metrics, etc.

  **Key benefits**:
  - No database needed (metadata in git)
  - Version-controlled and auditable
  - Team-wide visibility (pushed to remote)
  - Historical analysis (walk commits)

  ## Common Operations

  ### Operation 1: Fetch Git Notes

  Retrieve notes from remote repository.

  **Command Template**:
  ```bash
  # Fetch notes for a specific namespace
  git fetch origin refs/notes/ci/<namespace>:refs/notes/ci/<namespace> 2>/dev/null || \
    echo "No remote notes found for namespace: <namespace>"

  # Example namespaces:
  # - cache-metrics (Docker cache metrics)
  # - e2e-failures (E2E test failures)
  ```

  **Parameters**:
  - `<namespace>`: The notes namespace (e.g., cache-metrics, e2e-failures)

  **When to use**:
  - Before any analysis that reads git notes
  - After CI runs that push new notes
  - Periodically to sync latest metadata

  **Error handling**:
  - If remote notes don't exist: Inform user to set up CI capture
  - If fetch fails: Check network, permissions, remote URL

  ### Operation 2: Check If Notes Exist

  Verify notes are available before attempting to read them.

  **Command Template**:
  ```bash
  # Check if any notes exist for namespace
  git notes --ref=ci/<namespace> list | head -1

  # Check if specific commit has a note
  git notes --ref=ci/<namespace> show <commit-hash> >/dev/null 2>&1
  echo $?  # 0 = exists, 1 = doesn't exist
  ```

  **When to use**:
  - After fetching, to verify notes are available
  - Before showing notes for specific commit
  - To determine if CI capture is configured

  ### Operation 3: Show Note for Commit

  Retrieve the full note content for a specific commit.

  **Command Template**:
  ```bash
  # Show note for specific commit
  git notes --ref=ci/<namespace> show <commit-hash>

  # Show note for HEAD
  git notes --ref=ci/<namespace> show HEAD

  # Show note with error suppression
  git notes --ref=ci/<namespace> show <commit-hash> 2>/dev/null
  ```

  **Output**: Raw note content (typically INI format)

  **When to use**:
  - To view complete metadata for a commit
  - As input to parsing operations (see Operation 5)
  - For debugging note content

  ### Operation 4: List All Commits with Notes

  Find all commits that have notes in a namespace.

  **Command Template**:
  ```bash
  # List all commits with notes (shows object hash pairs)
  git notes --ref=ci/<namespace> list

  # Get just the commit hashes (second column)
  git notes --ref=ci/<namespace> list | awk '{print $2}'

  # Limit to recent commits
  git notes --ref=ci/<namespace> list | head -20
  ```

  **Output**: Lines with format: `<note-object-hash> <commit-hash>`

  **When to use**:
  - To find which commits have captured metadata
  - As input to historical analysis
  - To verify CI capture is working

  ### Operation 5: Parse INI Format Fields

  Extract specific fields from INI-format note data.

  **INI Format Structure**:
  ```ini
  # Top-level fields (key=value)
  timestamp = 2025-10-26T10:30:00Z
  commit = abc123de

  # Sections (bracket notation)
  [section_name]
  field1 = value1
  field2 = value2

  [another_section]
  data = something
  ```

  **Command Templates**:

  ```bash
  # Extract top-level field
  git notes --ref=ci/<namespace> show <commit> | \
    grep "^field_name" | cut -d'=' -f2 | xargs

  # Extract field from section
  git notes --ref=ci/<namespace> show <commit> | \
    grep -A 10 "^\[section_name\]" | grep "^field_name" | cut -d'=' -f2 | xargs

  # Extract all fields in a section
  git notes --ref=ci/<namespace> show <commit> | \
    sed -n '/^\[section_name\]/,/^\[/p' | grep "^[^[]" | grep -v "^$"

  # Count sections matching pattern
  git notes --ref=ci/<namespace> show <commit> | \
    grep -c "^\[failure\."  # Counts [failure.1], [failure.2], etc.
  ```

  **Common field extraction patterns**:

  ```bash
  # Extract timestamp
  git notes --ref=ci/<namespace> show HEAD | grep "^timestamp" | cut -d'=' -f2 | xargs

  # Extract status/result
  git notes --ref=ci/<namespace> show HEAD | grep "^status" | cut -d'=' -f2 | xargs

  # Extract multiple test names (from numbered sections)
  git notes --ref=ci/<namespace> show HEAD | grep "^test_name" | cut -d'=' -f2

  # Extract numeric metrics
  git notes --ref=ci/<namespace> show HEAD | grep "^total_tests" | cut -d'=' -f2 | xargs
  ```

  **When to use**:
  - To extract specific metrics from notes
  - To filter or aggregate data
  - As input to analysis calculations

  ### Operation 6: Get Commit Context

  Retrieve git commit information to provide context for notes.

  **Command Templates**:
  ```bash
  # Get commit summary
  git show --no-patch --format="%h: %s (%ar)" <commit-hash>

  # Get commit with full details
  git show --no-patch --format=full <commit-hash>

  # Get author and date
  git log --format="%an <%ae>%n%ar%n%ad" -1 <commit-hash>

  # Get files changed
  git diff-tree --no-commit-id --name-only -r <commit-hash>
  ```

  **When to use**:
  - To show what commit the note is attached to
  - To provide context in reports
  - To link metadata to code changes

  ### Operation 7: Historical Analysis

  Walk backwards through commits to analyze trends.

  **Command Templates**:

  ```bash
  # Get last N commits that have notes
  git log --oneline -50 --format="%H" | while read commit; do
    if git notes --ref=ci/<namespace> show "$commit" >/dev/null 2>&1; then
      echo "$commit"
    fi
  done | head -20

  # Simplified: Get last 10 commits with notes
  git notes --ref=ci/<namespace> list | head -10 | awk '{print $2}'

  # Walk backwards from HEAD until condition met
  for commit in $(git log --oneline -30 --format="%H"); do
    if git notes --ref=ci/<namespace> show "$commit" 2>/dev/null | grep -q "status = passed"; then
      echo "First passing commit: $commit"
      break
    fi
  done
  ```

  **Avoiding complex loops in Claude Code**:

  Claude Code's Bash tool has issues with complex while loops. Use simpler approaches:

  **❌ Avoid**:
  ```bash
  # Complex loop with process substitution
  while IFS= read -r commit; do
    note=$(git notes --ref=ci/<namespace> show "$commit" 2>/dev/null)
    if [ $? -eq 0 ]; then
      field=$(echo "$note" | grep "^field" | cut -d'=' -f2)
      echo "$commit: $field"
    fi
  done < <(git log --format="%H" -20)
  ```

  **✅ Prefer**:
  ```bash
  # Step 1: Get commit list
  git notes --ref=ci/<namespace> list | head -20

  # Step 2: For each commit, separate commands
  # Extract commit hash from list output (second column)

  # Step 3: Show note
  git notes --ref=ci/<namespace> show <hash>

  # Step 4: Parse field
  git notes --ref=ci/<namespace> show <hash> | grep "^field" | cut -d'=' -f2 | xargs
  ```

  **When to use**:
  - Trend analysis over time
  - Finding when issue first occurred
  - Calculating historical metrics
  - Comparing current vs past performance

  ### Operation 8: Compare Two Commits

  Compare notes between two commits to detect changes.

  **Command Templates**:

  ```bash
  # Get notes for current and previous
  CURRENT=$(git rev-parse HEAD)
  PREVIOUS=$(git rev-parse HEAD~1)

  git notes --ref=ci/<namespace> show $CURRENT > current.txt
  git notes --ref=ci/<namespace> show $PREVIOUS > previous.txt

  # Show differences
  diff previous.txt current.txt

  # Extract specific field from both
  CURRENT_VALUE=$(git notes --ref=ci/<namespace> show $CURRENT | grep "^metric" | cut -d'=' -f2 | xargs)
  PREVIOUS_VALUE=$(git notes --ref=ci/<namespace> show $PREVIOUS | grep "^metric" | cut -d'=' -f2 | xargs)

  # Calculate change
  echo "Change: $PREVIOUS_VALUE -> $CURRENT_VALUE"

  # Cleanup
  rm current.txt previous.txt
  ```

  **When to use**:
  - Detect regressions (current worse than previous)
  - Track improvements
  - Identify what changed between runs
  - Regression alerts

  ## Writing Git Notes in CI

  This section covers how to **create** git notes in CI workflows (GitHub Actions).
  The patterns below are used in this project's CI workflows to capture metadata.

  ### Post-Job Architecture for Accurate Status Capture

  **Problem**: Within a GitHub Actions job, `${{ job.status }}` always evaluates to "running"
  during execution, making it impossible to capture the final result (success/failure/cancelled).

  **Solution**: Use a separate post-job that runs AFTER the main job completes.

  **Implementation Pattern**:

  ```yaml
  jobs:
    main-job:
      runs-on: ubuntu-latest
      outputs:
        # Export step success flags as job outputs
        step1_success: ${{ steps.step1.outputs.success }}
        step2_success: ${{ steps.step2.outputs.success }}
      steps:
        - name: Some step
          id: step1
          run: |
            # ... do work
            echo "success=true" >> $GITHUB_OUTPUT  # Only set if successful

        - name: Another step
          id: step2
          run: |
            # ... do work
            echo "success=true" >> $GITHUB_OUTPUT

    # Post-job captures accurate final status
    capture-metadata:
      needs: [main-job]
      if: always()  # Run even if main-job fails
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
          with:
            fetch-depth: 0  # Need full history for git notes

        - name: Capture workflow metadata
          run: |
            # Accurate final status from needs context
            STATUS="${{ needs.main-job.result }}"  # success, failure, cancelled, skipped
            STEP1="${{ needs.main-job.outputs.step1_success || 'false' }}"
            STEP2="${{ needs.main-job.outputs.step2_success || 'false' }}"

            # Generate INI-format metadata
            cat > note.txt <<EOF
            timestamp = $(date -u +"%Y-%m-%dT%H:%M:%SZ")
            commit = ${{ github.sha }}
            workflow_status = $STATUS
            step1_success = $STEP1
            step2_success = $STEP2
            run_url = ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            EOF

            # Attach note to commit
            git notes --ref=ci/my-namespace add -F note.txt ${{ github.sha }}

        - name: Push notes to remote
          run: |
            git push origin refs/notes/ci/my-namespace
  ```

  **Key Benefits**:
  - ✅ Captures accurate final status (not "running")
  - ✅ Runs even when main job fails (`if: always()`)
  - ✅ Identifies which specific step failed (via outputs)
  - ✅ Enables reliable workflow analytics

  **Real Examples in This Project**:
  - `.github/workflows/update-snapshots.yml` - Snapshot update workflow with metadata capture
  - `.github/workflows/ci.yml` - E2E tests with cache metrics capture

  ### INI Format for Note Data

  Git notes in this project use INI format for structured data:

  ```ini
  # Top-level fields (key=value)
  timestamp = 2025-10-26T10:30:00Z
  commit = abc123def456
  status = success

  # Sections (bracket notation)
  [metadata]
  workflow = ci.yml
  run_id = 123456

  [summary]
  total_tests = 42
  passed = 40
  failed = 2

  # Numbered sections for multiple items
  [failure.1]
  test_name = ExpenseTracker › Add expense
  error_message = Timeout waiting for element

  [failure.2]
  test_name = Login › Invalid credentials
  error_message = Expected "error" class
  ```

  **Why INI format?**
  - Simple to parse with grep/cut/sed
  - Human-readable for debugging
  - Supports sections for structured data
  - Easy to extend with new fields

  ## Best Practices

  ### 1. Always Fetch First

  ```bash
  # Never assume notes are available locally
  git fetch origin refs/notes/ci/<namespace>:refs/notes/ci/<namespace> 2>/dev/null
  ```

  ### 2. Handle Missing Notes Gracefully

  ```bash
  # Check before reading
  if git notes --ref=ci/<namespace> list | head -1 >/dev/null 2>&1; then
    # Notes exist, proceed
    git notes --ref=ci/<namespace> show HEAD
  else
    echo "No notes found. CI capture may not be set up."
  fi
  ```

  ### 3. Use Error Suppression for Conditional Checks

  ```bash
  # Suppress stderr when checking existence
  if git notes --ref=ci/<namespace> show $commit 2>/dev/null; then
    echo "Note exists"
  else
    echo "No note for this commit"
  fi
  ```

  ### 4. Parse Incrementally (Avoid Complex Loops)

  ```bash
  # Bad: Complex one-liner
  git log -20 --format="%H" | while read c; do echo "$(git notes --ref=ci/foo show $c | grep field)"; done

  # Good: Step by step
  # Step 1: Get commits
  git notes --ref=ci/foo list | head -20

  # Step 2: For each commit (separate commands)
  git notes --ref=ci/foo show <hash1>
  git notes --ref=ci/foo show <hash2>
  # ... parse each individually
  ```

  ### 5. Clean Up Temp Files

  ```bash
  # Always clean up after file-based comparisons
  rm -f current.txt previous.txt *.tmp
  ```

  ## Common Patterns

  ### Pattern 1: Fetch and Validate

  ```bash
  # 1. Fetch notes
  git fetch origin refs/notes/ci/cache-metrics:refs/notes/ci/cache-metrics 2>/dev/null

  # 2. Check if any exist
  if ! git notes --ref=ci/cache-metrics list | head -1 >/dev/null 2>&1; then
    echo "❌ No cache metrics found. Set up CI capture first."
    exit 1
  fi

  # 3. Proceed with analysis
  echo "✅ Notes found, starting analysis..."
  ```

  ### Pattern 2: Extract Recent Metrics

  ```bash
  # Get last 10 commits with notes
  echo "Recent commits with notes:"
  git notes --ref=ci/cache-metrics list | head -10 | while read note_hash commit_hash; do
    # Get commit summary
    summary=$(git show --no-patch --format="%h: %s (%ar)" $commit_hash)

    # Get metric from note
    metric=$(git notes --ref=ci/cache-metrics show $commit_hash | grep "^cache_status" | cut -d'=' -f2 | xargs)

    echo "$summary -> $metric"
  done
  ```

  ### Pattern 3: Find First Failure

  ```bash
  # Walk backwards to find when test started failing
  echo "Finding first failure..."

  for commit in $(git log --oneline -30 --format="%H"); do
    # Check if commit has note
    if ! git notes --ref=ci/e2e-failures show "$commit" >/dev/null 2>&1; then
      echo "✅ First passing commit (no failure note): $commit"
      git show --no-patch --format="%h: %s (%ar)" "$commit"
      break
    fi

    # Check if specific test failed
    if git notes --ref=ci/e2e-failures show "$commit" | grep -q "test_name = ExpenseTracker"; then
      echo "❌ Failed at: $commit"
    else
      echo "✅ Passed at: $commit (first failure after this)"
      break
    fi
  done
  ```

  ### Pattern 4: Calculate Aggregate Metrics

  ```bash
  # Calculate average or totals across commits
  total=0
  count=0

  for commit_hash in $(git notes --ref=ci/cache-metrics list | head -20 | awk '{print $2}'); do
    value=$(git notes --ref=ci/cache-metrics show $commit_hash | grep "^metric_value" | cut -d'=' -f2 | xargs)

    if [ -n "$value" ]; then
      total=$((total + value))
      count=$((count + 1))
    fi
  done

  if [ $count -gt 0 ]; then
    average=$((total / count))
    echo "Average metric: $average (across $count commits)"
  fi
  ```

  ## Troubleshooting

  ### Issue: "No notes found"

  **Symptoms**: `git notes --ref=ci/<namespace> list` returns empty

  **Causes**:
  1. Notes haven't been fetched from remote
  2. CI hasn't captured any notes yet
  3. Wrong namespace name

  **Solutions**:
  ```bash
  # Fetch from remote
  git fetch origin refs/notes/ci/<namespace>:refs/notes/ci/<namespace>

  # List all notes refs
  git for-each-ref refs/notes/

  # Check if remote has notes
  git ls-remote origin refs/notes/*
  ```

  ### Issue: "Field not found when parsing"

  **Symptoms**: `grep "^field_name"` returns empty

  **Causes**:
  1. Field name typo
  2. Field is in a section (need -A flag)
  3. INI format issue (extra spaces, different format)

  **Solutions**:
  ```bash
  # Show full note to verify format
  git notes --ref=ci/<namespace> show <commit>

  # Try case-insensitive search
  grep -i "field_name"

  # Try matching with wildcard
  grep "field_name\s*="

  # Check for fields in sections
  grep -A 20 "^\[section\]" | grep "field_name"
  ```

  ### Issue: "Note exists but shows wrong commit"

  **Symptoms**: Note content doesn't match expected commit

  **Cause**: Note attached to wrong commit

  **Solution**:
  ```bash
  # Verify commit hash
  git rev-parse <commit>

  # Show note with commit context
  git log --show-notes=ci/<namespace> --format="%H %s" -1 <commit>
  ```

tips:
  - "Always fetch notes before reading: `git fetch origin refs/notes/ci/<namespace>`"
  - "Use `2>/dev/null` to suppress stderr when checking note existence"
  - "Parse INI fields with: `grep '^field' | cut -d'=' -f2 | xargs`"
  - "Extract commit hash from notes list with: `awk '{print $2}'`"
  - "Avoid complex while loops in Claude Code Bash tool (use simple sequential commands)"
  - "Clean up temp files after file-based operations"
  - "Use `git show --no-patch` to get commit info without diff"
  - "For historical analysis, limit to reasonable range (20-30 commits)"

common_namespaces:
  cache-metrics:
    description: "Docker build cache efficiency metrics from CI"
    fields:
      - "timestamp"
      - "commit"
      - "base_image"
      - "cache_status"
      - "change_type"
      - "run_url"

  e2e-failures:
    description: "Playwright E2E test failure metadata from CI"
    sections:
      - "[metadata]"
      - "[summary]"
      - "[failure.N]"
      - "[diagnostics]"
    fields:
      - "timestamp"
      - "commit"
      - "total_tests"
      - "passed"
      - "failed"
      - "test_name"
      - "error_message"

  snapshot-updates:
    description: "Visual snapshot update workflow execution metadata from CI"
    sections:
      - "[metadata]"
      - "[execution]"
      - "[snapshot_changes]"
      - "[diagnostics]"
      - "[error_details]"
      - "[test_results]"
      - "[timing]"
      - "[trigger_details]"
    fields:
      - "timestamp"
      - "commit"
      - "status (success, failure, timeout, in_progress)"
      - "outcome (snapshots_updated, no_changes_needed, failed, in_progress)"
      - "error_step"
      - "error_message"
      - "playwright_exit_code"
      - "docker_container_status"
      - "playwright_error_log (captured Docker logs)"
      - "total_tests"
      - "passed"
      - "failed"
      - "skipped"
      - "job_duration_seconds"
      - "timed_out"
      - "triggered_by (push, issue_comment, workflow_dispatch)"

output_format: |
  When using this skill to provide git notes operations:

  1. **Show commands** used (for transparency and learning)
  2. **Explain parameters** (namespace, commit hash)
  3. **Handle errors gracefully** (missing notes, fetch failures)
  4. **Provide context** (what note contains, what it means)
  5. **Format output** clearly (use tables, sections, visual indicators)

examples:
  fetch_and_check:
    scenario: "Fetch notes and verify they exist"
    commands:
      - "git fetch origin refs/notes/ci/cache-metrics:refs/notes/ci/cache-metrics"
      - "git notes --ref=ci/cache-metrics list | head -5"
      - "echo 'Found X commits with cache metrics'"

  extract_field:
    scenario: "Extract specific field from current commit's note"
    commands:
      - "git notes --ref=ci/cache-metrics show HEAD"
      - "git notes --ref=ci/cache-metrics show HEAD | grep '^cache_status' | cut -d'=' -f2 | xargs"
      - "echo 'Cache status: HIT'"

  compare_commits:
    scenario: "Compare metrics between current and previous commit"
    commands:
      - "CURRENT=$(git notes --ref=ci/cache-metrics show HEAD | grep '^value' | cut -d'=' -f2)"
      - "PREVIOUS=$(git notes --ref=ci/cache-metrics show HEAD~1 | grep '^value' | cut -d'=' -f2)"
      - "echo 'Change: $PREVIOUS -> $CURRENT'"

  find_first_occurrence:
    scenario: "Find when a metric first appeared"
    commands:
      - "git log --oneline -20 --format='%H'"
      - "git notes --ref=ci/cache-metrics show <hash1> | grep 'cache_status'"
      - "git notes --ref=ci/cache-metrics show <hash2> | grep 'cache_status'"
      - "echo 'First occurrence at commit <hash>'"
