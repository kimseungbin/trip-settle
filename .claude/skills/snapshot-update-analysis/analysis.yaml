name: snapshot-update-analysis
description: |
  Analyze visual snapshot update workflow execution from git notes.

  Use this skill to:
  - Review snapshot update workflow success/failure patterns
  - Identify why snapshot updates are failing
  - Track which trigger methods are being used
  - Get recommendations for resolving workflow issues
  - Monitor snapshot update frequency and patterns

instructions: |
  When the user requests snapshot update workflow analysis or asks about snapshot update failures:

  ## Prerequisites: Git Notes Helper Skill

  This skill uses git notes to store and retrieve snapshot update metadata. Before starting analysis:

  1. **Reference git-notes-helper skill** for common operations:
     - Read `.claude/skills/git-notes-helper/helper.yaml` for git notes operations
     - Use namespace: `ci/snapshot-updates`
     - Follow patterns from git-notes-helper for fetching, parsing, and historical analysis

  2. **Key operations from git-notes-helper**:
     - Fetch notes: Operation 1
     - Check existence: Operation 2
     - Show note: Operation 3
     - Parse INI fields: Operation 5
     - Historical analysis: Operation 7
     - Compare commits: Operation 8

  ## Background: How Metadata Is Captured

  Before analyzing metadata, understand how it's generated in the snapshot update workflow:

  ### Workflow Integration

  The `.github/workflows/update-snapshots.yml` workflow includes metadata capture:

  ```yaml
  - name: Capture workflow metadata in git notes
    if: always()  # Run even if previous steps failed
    run: |
      # Extract metadata
      ./.github/scripts/extract-snapshot-update-metadata.sh snapshot-update-note.txt

      # Store in git notes
      git config user.name "github-actions[bot]"
      git config user.email "github-actions[bot]@users.noreply.github.com"
      git notes --ref=ci/snapshot-updates add -F snapshot-update-note.txt ${{ github.sha }}

      # Push to remote
      git push origin refs/notes/ci/snapshot-updates
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  ```

  **Key points:**
  - Runs with `if: always()` to capture failures
  - Uses `extract-snapshot-update-metadata.sh` to generate note
  - Stores notes in `refs/notes/ci/snapshot-updates` namespace
  - Pushes notes to remote for team access

  ### Extraction Script Logic

  The `.github/scripts/extract-snapshot-update-metadata.sh` script extracts:

  **What it captures:**
  - Trigger method (workflow_dispatch, issue_comment, push)
  - Workflow status (success, failure, in_progress)
  - Step-level success/failure (checkout, docker, playwright, commit, push)
  - Snapshot changes (whether changes occurred, file count)
  - Error details (failed step, error message)

  **Output format:** INI-style structure (see examples below)

  ### Example Metadata Note Structure

  ```ini
  === SNAPSHOT UPDATE WORKFLOW REPORT ===

  [metadata]
  timestamp = 2025-10-26T17:30:00Z
  commit = 5dea278
  branch = main
  run_url = https://github.com/user/repo/actions/runs/12345
  workflow = update-snapshots
  triggered_by = push

  [execution]
  status = success
  outcome = snapshots_updated
  checkout_step = true
  docker_setup = true
  playwright_tests = true
  commit_step = true
  push_step = true

  [snapshot_changes]
  has_changes = true
  files_changed = 12
  committed = true
  pushed = true

  [diagnostics]
  error_step = none
  error_message = none
  test_env = ci-docker
  updating_snapshots = true
  docker_user = root

  [trigger_details]
  method = push
  # workflow_dispatch: Manual trigger from GitHub UI
  # issue_comment: Triggered by /update-snapshots PR comment
  # push: Triggered by [update-snapshots] in commit message
  source_branch = main

  [recommendations]
  next_steps = Review snapshot changes in git diff. Ensure visual changes are intentional.
  ```

  ## Step 1: Fetch and Validate Snapshot Update Notes

  Use **git-notes-helper** Operations 1-2:

  ```bash
  # Operation 1: Fetch notes from remote
  git fetch origin refs/notes/ci/snapshot-updates:refs/notes/ci/snapshot-updates 2>/dev/null || \
    echo "No remote snapshot update notes found (notes may not be set up yet)"

  # Operation 2: Check if any notes exist locally
  git notes --ref=ci/snapshot-updates list | head -5
  ```

  If no notes exist, inform the user that the workflow needs to capture metadata first.

  ## Step 2: Extract Recent Workflow Executions

  Use **git-notes-helper** Operations 3-7 to retrieve snapshot update metadata:

  **Reference**: See `.claude/skills/git-notes-helper/helper.yaml` ‚Üí Operation 7 (Historical Analysis) for detailed patterns.

  **Simplified workflow** (follows git-notes-helper best practices):

  ```bash
  # List recent commits with snapshot update notes (Operation 4)
  git notes --ref=ci/snapshot-updates list | head -20

  # For each commit hash, extract data (Operations 3, 5, 6):

  # Show note content (Operation 3)
  git notes --ref=ci/snapshot-updates show <commit-hash>

  # Parse specific fields (Operation 5)
  git notes --ref=ci/snapshot-updates show <commit-hash> | grep "^outcome" | cut -d'=' -f2 | xargs
  git notes --ref=ci/snapshot-updates show <commit-hash> | grep "^triggered_by" | cut -d'=' -f2 | xargs
  git notes --ref=ci/snapshot-updates show <commit-hash> | grep "^error_step" | cut -d'=' -f2 | xargs

  # Get commit context (Operation 6)
  git show --no-patch --format="%h: %s (%ar)" <commit-hash>
  ```

  **Important**: Follow git-notes-helper "Best Practices" ‚Üí Avoid complex while loops, use simple sequential commands.

  ## Step 3: Analyze Workflow Patterns

  Parse the extracted data and identify patterns:

  ### Key Metrics to Analyze:

  1. **Success Rate**
     - Count success vs failure outcomes
     - Calculate percentage
     - Identify recent failures

  2. **Trigger Method Distribution**
     - How often each trigger is used (workflow_dispatch, issue_comment, push)
     - Which triggers have higher failure rates

  3. **Step-Level Failures**
     - Which steps fail most often (checkout, docker, playwright, commit, push)
     - Identify consistent failure points

  4. **Snapshot Change Patterns**
     - How often snapshots actually change (has_changes)
     - Average number of files changed
     - Commits with no changes (workflow ran unnecessarily)

  5. **Error Analysis**
     - Common error messages
     - Failed steps correlation
     - Trends in specific error types

  ### Analysis Template:

  ```
  === SNAPSHOT UPDATE WORKFLOW ANALYSIS ===

  Period: [oldest_timestamp] to [newest_timestamp]
  Workflow runs analyzed: [count]

  ## Overall Workflow Health

  Success Rate: [X]% ([success_count]/[total_count])
  - Successful updates: [count]
  - Failed updates: [count]
  - No changes needed: [count]

  ## Trigger Method Usage

  | Trigger Method    | Count | Success Rate | Avg Files Changed |
  |-------------------|-------|--------------|-------------------|
  | push ([update...])| [X]   | [Y]%         | [Z]               |
  | issue_comment     | [X]   | [Y]%         | [Z]               |
  | workflow_dispatch | [X]   | [Y]%         | [Z]               |

  ## Step-Level Failure Analysis

  | Step             | Failure Count | % of Total Failures |
  |------------------|---------------|---------------------|
  | checkout         | [X]           | [Y]%                |
  | docker_setup     | [X]           | [Y]%                |
  | playwright_tests | [X]           | [Y]%                |
  | commit           | [X]           | [Y]%                |
  | push             | [X]           | [Y]%                |

  ## Snapshot Change Patterns

  Average files changed per update: [X]
  - Largest update: [Y] files (commit: [hash])
  - Smallest update: [Z] files (commit: [hash])

  Workflow runs with no changes: [X] ([Y]% of total)
  - Consider: Are these necessary or could trigger detection be improved?

  ## Recent Failures

  [List last 3-5 failures with details:]
  1. Commit [hash] ([timestamp])
     - Trigger: [method]
     - Failed at: [step]
     - Error: [message]
     - Run URL: [url]

  ## Trends & Patterns

  [Identify concerning patterns, e.g.:]
  - ‚ö†Ô∏è Playwright tests failing consistently since commit abc123
  - ‚ö†Ô∏è Push step fails when multiple snapshot files change
  - ‚úì workflow_dispatch trigger has 100% success rate
  - üìä Most updates triggered by [update-snapshots] in commit messages

  ## Recommendations

  [Provide actionable insights based on analysis:]

  **If high failure rate:**
  - Review error messages in failed runs
  - Check Playwright configuration for visual test stability
  - Verify Docker setup isn't timing out

  **If frequent "no changes" runs:**
  - Review trigger detection logic in check-trigger.sh
  - Consider adding pre-check to avoid unnecessary runs

  **If specific step fails consistently:**
  - [checkout]: Check branch permissions and checkout configuration
  - [docker_setup]: Review Docker Buildx setup, may need resource limits
  - [playwright_tests]: Visual snapshots may be flaky, review test stability
  - [commit]: Git configuration or file permissions issue
  - [push]: Authentication or branch protection rules

  **If specific trigger has issues:**
  - [push]: Check commit message parsing in check-trigger.sh
  - [issue_comment]: Verify PR comment detection logic
  - [workflow_dispatch]: Manual triggers working well, no action needed
  ```

  ## Step 4: Deep Dive into Specific Failure

  If user requests details about a specific failed run:

  ```bash
  # Show full note for a commit
  git notes --ref=ci/snapshot-updates show <commit>

  # Find the GitHub Actions run URL
  git notes --ref=ci/snapshot-updates show <commit> | grep "^run_url"

  # Extract error details
  git notes --ref=ci/snapshot-updates show <commit> | grep -E "^error_step|^error_message"

  # Check what changed in the commit
  git show --stat <commit>
  ```

  ## Step 5: Compare Success vs Failure Patterns

  To identify what distinguishes successful from failed runs:

  ```bash
  # Extract outcomes for recent commits
  git notes --ref=ci/snapshot-updates list | head -20 | awk '{print $2}' | while read commit; do
    outcome=$(git notes --ref=ci/snapshot-updates show $commit | grep "^outcome" | cut -d'=' -f2 | xargs)
    trigger=$(git notes --ref=ci/snapshot-updates show $commit | grep "^triggered_by" | cut -d'=' -f2 | xargs)
    files=$(git notes --ref=ci/snapshot-updates show $commit | grep "^files_changed" | cut -d'=' -f2 | xargs)
    echo "$commit,$outcome,$trigger,$files"
  done
  ```

examples:
  basic_analysis:
    user_request: "Analyze snapshot update workflow"
    steps:
      - "Fetch git notes: `git fetch origin refs/notes/ci/snapshot-updates:refs/notes/ci/snapshot-updates`"
      - "Extract metadata from last 20 workflow runs"
      - "Calculate success rate and trigger distribution"
      - "Identify failed steps and error patterns"
      - "Present findings with recommendations"

  specific_failure:
    user_request: "Why did the snapshot update fail on commit abc123?"
    steps:
      - "Fetch notes if not available"
      - "Run: `git notes --ref=ci/snapshot-updates show abc123`"
      - "Parse error_step and error_message"
      - "Extract run_url for detailed logs"
      - "Show commit changes: `git show abc123`"
      - "Provide diagnosis and remediation steps"

  time_range:
    user_request: "Show snapshot update success rate for the last week"
    steps:
      - "Get commits from last 7 days"
      - "Extract snapshot update metadata for those commits"
      - "Calculate success vs failure rate"
      - "Group by trigger method"
      - "Identify any anomalies or trends"

  trigger_analysis:
    user_request: "Which trigger method is most reliable?"
    steps:
      - "Extract all workflow runs"
      - "Group by triggered_by (push, issue_comment, workflow_dispatch)"
      - "Calculate success rate per trigger"
      - "Analyze average files changed per trigger"
      - "Present comparison table"

  step_failure_analysis:
    user_request: "Which step is failing most often?"
    steps:
      - "Extract all failed workflow runs"
      - "Parse error_step for each failure"
      - "Count failures by step"
      - "Calculate percentage of total failures"
      - "Recommend specific fixes based on most common failure point"

common_issues:
  stale_running_status:
    symptom: "Commits show 'status = running' hours after workflow completed"
    cause: "Post-job metadata capture occurred before workflow timed out or failed"
    solution: |
      Check the timestamp field - if it's old (>30 minutes), the workflow likely:
      1. Timed out (check timeout-minutes setting in workflow)
      2. Failed without proper error propagation
      3. Got stuck in Docker operations

      Investigation steps:
      - Check GitHub Actions logs via run_url in metadata
      - Look for "SIGTERM" or "timeout" in workflow logs
      - Verify Docker compose exit codes are being captured

      Prevention: Ensure workflow has proper timeout and error handling

  no_notes_found:
    symptom: "No git notes found"
    solution: |
      The snapshot update workflow hasn't captured metadata yet.
      Steps to enable:
      1. Ensure the "Capture workflow metadata" step is in .github/workflows/update-snapshots.yml
      2. Trigger the workflow (commit with [update-snapshots] or manual trigger)
      3. After workflow completes, fetch notes: `git fetch origin refs/notes/ci/snapshot-updates`

  high_failure_rate:
    symptom: "Most snapshot updates are failing"
    causes:
      - "Playwright tests unstable or flaky"
      - "Docker setup timing out"
      - "Git authentication issues (push step)"
      - "Branch protection rules preventing push"
    solution: "Check error_step to identify which phase fails, then review specific step configuration"

  no_changes_detected:
    symptom: "Workflow runs but reports no changes"
    causes:
      - "Snapshots already up to date"
      - "Workflow triggered unnecessarily"
      - "Git diff not detecting snapshot file changes"
    solution: |
      This may be normal. Review:
      - Whether trigger detection could be improved
      - If snapshots are actually changing in Playwright output
      - Git diff command in "Check for snapshot changes" step

  push_failures:
    symptom: "commit_step succeeds but push_step fails"
    causes:
      - "Branch protection rules require PR"
      - "GITHUB_TOKEN lacks write permissions"
      - "Network timeout during push"
    solution: |
      Check GitHub repository settings:
      - Settings ‚Üí Branches ‚Üí Branch protection rules
      - Allow GitHub Actions to bypass protection
      - Verify workflow has `contents: write` permission

tips:
  - "Reference git-notes-helper skill for all git notes operations"
  - "Use namespace: `ci/snapshot-updates` for all snapshot update notes"
  - "Follow git-notes-helper best practices for parsing and historical analysis"
  - "Look for patterns in error_step to identify systematic issues"
  - "Compare trigger methods - manual triggers (workflow_dispatch) often more reliable"
  - "Check if failures correlate with large snapshot changes (many files)"
  - "Review GitHub Actions run logs via run_url for detailed error messages"
  - "IMPORTANT: Avoid complex while loops with pipes - use simple for loops with explicit commit lists"
  - "Check timestamp age - 'status=running' with old timestamp (>30min) indicates timeout or stale metadata"
  - "When playwright_tests fails consistently, check: timeout duration, Docker resource limits, test flakiness"

output_format: |
  Present analysis in clear sections:
  1. Overall workflow health (success rate)
  2. Trigger method distribution and reliability
  3. Step-level failure breakdown
  4. Snapshot change patterns
  5. Recent failures with details
  6. Trends identification
  7. Prioritized recommendations

  Use visual indicators:
  - ‚úì for successful patterns
  - ‚ö†Ô∏è for concerning trends
  - üìä for statistical insights
  - üí° for recommendations
  - üîç for areas needing investigation