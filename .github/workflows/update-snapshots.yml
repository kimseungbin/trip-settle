name: Update Visual Snapshots

# This workflow updates visual regression test snapshots in the remote CI environment.
# Visual tests should NEVER be updated locally due to rendering inconsistencies.
#
# Trigger methods:
# 1. Manual: Go to Actions tab ‚Üí "Update Visual Snapshots" ‚Üí Run workflow
# 2. PR Comment: Comment "/update-snapshots" on a pull request
# 3. Commit Footer: Add "Snapshots: update" footer to commit message

on:
  # Manual trigger from GitHub UI
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to update snapshots on'
        required: false
        default: ''

  # Trigger via PR comment
  issue_comment:
    types: [created]

  # Trigger via commit footer containing "Snapshots: update"
  push:
    branches:
      - '**'

# Prevent simultaneous snapshot update runs on the same branch
# Queue new runs to ensure all updates complete without conflicts
concurrency:
  group: update-snapshots-${{ github.ref }}
  cancel-in-progress: false

# Sets permissions of the GITHUB_TOKEN to allow pushing commits and git notes
permissions:
  contents: write

jobs:
  # Check if workflow should run
  check-trigger:
    name: Check Trigger Condition
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      branch: ${{ steps.check.outputs.branch }}
      test_scope: ${{ steps.check.outputs.test_scope }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check trigger condition
        id: check
        uses: ./.github/actions/check-snapshot-trigger

  # Update snapshots
  update-snapshots:
    name: Update Snapshots in CI
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'
    timeout-minutes: 30
    outputs:
      checkout_success: ${{ steps.record_checkout.outputs.success }}
      docker_success: ${{ steps.record_docker.outputs.success }}
      playwright_success: ${{ steps.record_playwright.outputs.success }}
      playwright_exit_code: ${{ steps.record_playwright.outputs.exit_code }}
      playwright_error_log: ${{ steps.capture_error_details.outputs.error_log }}
      docker_container_status: ${{ steps.capture_error_details.outputs.container_status }}
      tests_total: ${{ steps.extract_results.outputs.tests_total }}
      tests_passed: ${{ steps.extract_results.outputs.tests_passed }}
      tests_failed: ${{ steps.extract_results.outputs.tests_failed }}
      tests_skipped: ${{ steps.extract_results.outputs.tests_skipped }}
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
      files_changed: ${{ steps.check_changes.outputs.files_count }}
      commit_success: ${{ steps.record_commit.outputs.success }}
      push_success: ${{ steps.record_push.outputs.success }}
      job_start_time: ${{ steps.record_start.outputs.start_time }}

    steps:
      - name: Record job start time
        id: record_start
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.check-trigger.outputs.branch }}
          # Need write access to push changes
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Record checkout success
        id: record_checkout
        run: echo "success=true" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Record Docker setup success
        id: record_docker
        run: echo "success=true" >> $GITHUB_OUTPUT

      - name: Cleanup existing Docker resources
        run: ./.github/scripts/docker/cleanup-resources.sh docker-compose.e2e.yml

      - name: Run visual tests with snapshot update
        id: record_playwright
        timeout-minutes: 25  # Full snapshot updates with 4 browsers can take 15-20 minutes
        run: |
          set -e  # Exit immediately on any error

          TEST_SCOPE="${{ needs.check-trigger.outputs.test_scope }}"
          echo "üì∏ Updating visual snapshots in remote CI environment..."
          echo "‚ÑπÔ∏è  Test scope: $TEST_SCOPE"
          echo "‚è∞ Started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          # Build Playwright test pattern based on scope
          case "$TEST_SCOPE" in
            visual)
              TEST_PATTERN="tests/visual/"
              echo "   Running only visual tests (tests/visual/)"
              ;;
            e2e)
              TEST_PATTERN="tests/e2e/"
              echo "   Running only e2e tests (tests/e2e/)"
              ;;
            all|*)
              TEST_PATTERN=""  # Empty = all tests
              echo "   Running all visual tests (tests/visual/ and tests/e2e/)"
              ;;
          esac

          # Pass test pattern to Playwright via environment variable
          export PLAYWRIGHT_TEST_PATTERN="$TEST_PATTERN"

          echo "üöÄ Starting Docker compose..."
          PLAYWRIGHT_ARGS="--update-snapshots" docker compose -f docker-compose.e2e.yml up --build --abort-on-container-exit
          EXIT_CODE=$?

          echo "‚è∞ Completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üìä Docker compose exit code: $EXIT_CODE"

          # Always record exit code for diagnostics
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::Playwright tests failed with exit code $EXIT_CODE"
            exit $EXIT_CODE
          fi

          echo "success=true" >> $GITHUB_OUTPUT
        env:
          DOCKER_USER: root
          TEST_ENV: ci-docker
          UPDATING_SNAPSHOTS: true

      - name: Capture error details
        if: always() && steps.record_playwright.outcome != 'skipped' && steps.record_playwright.outcome != 'success'
        id: capture_error_details
        run: |
          # Capture last 50 lines of Playwright container logs
          ERROR_LOG=$(docker compose -f docker-compose.e2e.yml logs playwright --tail=50 2>&1 | grep -E "Error:|FAIL|TIMEOUT|exit code" | head -20 || echo "No error logs captured")

          # Escape special characters for GitHub output
          ERROR_LOG=$(echo "$ERROR_LOG" | head -c 1000)  # Limit to 1000 chars
          ERROR_LOG="${ERROR_LOG//'%'/'%25'}"
          ERROR_LOG="${ERROR_LOG//$'\n'/'%0A'}"
          ERROR_LOG="${ERROR_LOG//$'\r'/'%0D'}"

          echo "error_log=$ERROR_LOG" >> $GITHUB_OUTPUT

          # Get container exit status
          CONTAINER_STATUS=$(docker compose -f docker-compose.e2e.yml ps -a playwright --format json 2>/dev/null | jq -r '.[0].State // "unknown"' || echo "unknown")
          echo "container_status=$CONTAINER_STATUS" >> $GITHUB_OUTPUT

          echo "üìã Captured error details"
          echo "   Container status: $CONTAINER_STATUS"
          echo "   Error log preview: ${ERROR_LOG:0:200}..."

      - name: Extract test results from Docker container
        if: always() && steps.record_playwright.outcome != 'skipped'
        id: extract_results
        run: |
          # Copy test results JSON from Docker volume if available
          docker compose -f docker-compose.e2e.yml cp playwright:/app/packages/frontend/test-results/results.json ./test-results.json 2>/dev/null || \
            echo "‚ö†Ô∏è Could not extract test results JSON (tests may not have run)"

          # Parse test results if JSON exists
          if [ -f ./test-results.json ]; then
            # Use jq to extract test statistics
            if command -v jq &> /dev/null; then
              TOTAL_TESTS=$(jq '.stats.expected + .stats.unexpected + .stats.flaky + .stats.skipped' ./test-results.json 2>/dev/null || echo "0")
              PASSED_TESTS=$(jq '.stats.expected' ./test-results.json 2>/dev/null || echo "0")
              FAILED_TESTS=$(jq '.stats.unexpected' ./test-results.json 2>/dev/null || echo "0")
              SKIPPED_TESTS=$(jq '.stats.skipped' ./test-results.json 2>/dev/null || echo "0")

              echo "tests_total=$TOTAL_TESTS" >> $GITHUB_OUTPUT
              echo "tests_passed=$PASSED_TESTS" >> $GITHUB_OUTPUT
              echo "tests_failed=$FAILED_TESTS" >> $GITHUB_OUTPUT
              echo "tests_skipped=$SKIPPED_TESTS" >> $GITHUB_OUTPUT

              echo "‚úÖ Extracted test results: $PASSED_TESTS passed, $FAILED_TESTS failed, $SKIPPED_TESTS skipped (total: $TOTAL_TESTS)"
            else
              echo "‚ö†Ô∏è jq not available, skipping test result parsing"
            fi
          fi

      - name: Capture Docker logs on failure
        if: failure() && steps.record_playwright.outcome == 'failure'
        run: |
          echo "üìã Capturing Docker compose logs..."
          docker compose -f docker-compose.e2e.yml logs --tail=500 > docker-logs.txt 2>&1 || echo "Failed to capture logs"

          if [ -f docker-logs.txt ]; then
            echo "--- Playwright Service Logs ---"
            docker compose -f docker-compose.e2e.yml logs playwright --tail=200 || echo "No playwright logs available"

            echo "--- Frontend Service Logs ---"
            docker compose -f docker-compose.e2e.yml logs frontend --tail=100 || echo "No frontend logs available"

            echo "--- Backend Service Logs ---"
            docker compose -f docker-compose.e2e.yml logs backend --tail=100 || echo "No backend logs available"
          fi

      - name: Upload Docker logs
        if: failure() && steps.record_playwright.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: docker-logs
          path: docker-logs.txt
          retention-days: 7

      - name: Check for snapshot changes
        id: check_changes
        run: |
          if git diff --quiet packages/frontend/tests; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "files_count=0" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No snapshot changes detected"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            CHANGED_COUNT=$(git diff --name-only packages/frontend/tests | wc -l | xargs)
            echo "files_count=${CHANGED_COUNT}" >> $GITHUB_OUTPUT
            echo "‚úÖ Snapshot changes detected (${CHANGED_COUNT} files)"
          fi

      - name: Configure git for bot
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: ./.github/actions/configure-git-bot

      - name: Commit and push snapshot updates
        id: record_commit
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git add packages/frontend/tests

          # Create descriptive commit message
          CHANGED_FILES=$(git diff --cached --name-only | wc -l)
          git commit -m "test(frontend): Update visual snapshots in CI [skip ci]

          Updated $CHANGED_FILES snapshot file(s) in remote CI environment.

          This ensures pixel-perfect consistency with the CI/CD pipeline.
          Visual snapshots should only be generated in the remote environment
          to avoid platform-specific rendering differences.

          ü§ñ Generated by GitHub Actions
          Workflow: ${{ github.workflow }}
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "success=true" >> $GITHUB_OUTPUT

      - name: Push snapshot updates
        id: record_push
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git push
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Comment on PR (if triggered by PR comment)
        if: github.event_name == 'issue_comment' && steps.check_changes.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚úÖ Visual snapshots have been updated in the remote CI environment and committed to this branch.\n\nPlease review the changes before merging.'
            })

      - name: Upload Playwright HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-snapshots
          path: packages/frontend/playwright-report/
          retention-days: 7

      - name: Upload visual test artifacts (failed + passed)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-test-artifacts
          path: |
            packages/frontend/test-results/**/test-failed-*.png
            packages/frontend/test-results/**/diff-*.png
            packages/frontend/test-results/**/*-actual.png
            packages/frontend/test-results/**/*-expected.png
            packages/frontend/test-results/**/error-context.md
            packages/frontend/tests/**/ui-snapshots.spec.ts-snapshots/*.png
          retention-days: 7

      - name: Summary
        run: |
          if [ "${{ steps.check_changes.outputs.has_changes }}" = "true" ]; then
            echo "### ‚úÖ Snapshots Updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Visual regression snapshots have been updated in the remote CI environment." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Changed files:** $(git diff HEAD~1 --name-only packages/frontend/tests | wc -l)" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ÑπÔ∏è No Changes" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No visual snapshot updates were needed." >> $GITHUB_STEP_SUMMARY
          fi

  # Capture workflow metadata in git notes (post-job)
  capture-metadata:
    name: Capture Workflow Metadata
    runs-on: ubuntu-latest
    needs: [check-trigger, update-snapshots]
    if: always() && needs.check-trigger.outputs.should_run == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Capture metadata in git notes
        run: |
          # Use needs context to get accurate final status
          # Fallback to 'timeout' if result is empty (happens when job times out)
          WORKFLOW_STATUS="${{ needs.update-snapshots.result }}"
          if [ -z "$WORKFLOW_STATUS" ] || [ "$WORKFLOW_STATUS" = "null" ]; then
            WORKFLOW_STATUS="timeout"
          fi

          CHECKOUT_SUCCESS="${{ needs.update-snapshots.outputs.checkout_success || 'false' }}"
          DOCKER_SUCCESS="${{ needs.update-snapshots.outputs.docker_success || 'false' }}"
          PLAYWRIGHT_SUCCESS="${{ needs.update-snapshots.outputs.playwright_success || 'false' }}"
          PLAYWRIGHT_EXIT_CODE="${{ needs.update-snapshots.outputs.playwright_exit_code || 'unknown' }}"
          PLAYWRIGHT_ERROR_LOG="${{ needs.update-snapshots.outputs.playwright_error_log || 'none' }}"
          DOCKER_CONTAINER_STATUS="${{ needs.update-snapshots.outputs.docker_container_status || 'unknown' }}"
          TESTS_TOTAL="${{ needs.update-snapshots.outputs.tests_total || '0' }}"
          TESTS_PASSED="${{ needs.update-snapshots.outputs.tests_passed || '0' }}"
          TESTS_FAILED="${{ needs.update-snapshots.outputs.tests_failed || '0' }}"
          TESTS_SKIPPED="${{ needs.update-snapshots.outputs.tests_skipped || '0' }}"
          HAS_CHANGES="${{ needs.update-snapshots.outputs.has_changes || 'false' }}"
          CHANGED_FILES_COUNT="${{ needs.update-snapshots.outputs.files_changed || '0' }}"
          COMMIT_SUCCESS="${{ needs.update-snapshots.outputs.commit_success || 'false' }}"
          PUSH_SUCCESS="${{ needs.update-snapshots.outputs.push_success || 'false' }}"
          JOB_START_TIME="${{ needs.update-snapshots.outputs.job_start_time || 'unknown' }}"
          TRIGGER_METHOD="${{ github.event_name }}"

          # Export for extraction script
          export WORKFLOW_STATUS
          export CHECKOUT_SUCCESS
          export DOCKER_SUCCESS
          export PLAYWRIGHT_SUCCESS
          export PLAYWRIGHT_EXIT_CODE
          export PLAYWRIGHT_ERROR_LOG
          export DOCKER_CONTAINER_STATUS
          export TESTS_TOTAL
          export TESTS_PASSED
          export TESTS_FAILED
          export TESTS_SKIPPED
          export HAS_CHANGES
          export CHANGED_FILES_COUNT
          export COMMIT_SUCCESS
          export PUSH_SUCCESS
          export JOB_START_TIME
          export TRIGGER_METHOD

          # Extract metadata
          ./.github/scripts/extract-snapshot-update-metadata.sh snapshot-update-note.txt

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch existing notes (may not exist yet)
          git fetch origin refs/notes/ci/snapshot-updates:refs/notes/ci/snapshot-updates 2>/dev/null || \
            echo "‚ÑπÔ∏è No existing notes found (first run)"

          # Add note to current commit
          if git notes --ref=ci/snapshot-updates add -F snapshot-update-note.txt ${{ github.sha }} 2>/dev/null; then
            echo "‚úÖ Snapshot update metadata note created"
          else
            # Note already exists, append instead
            echo "‚ÑπÔ∏è Note already exists, updating..."
            git notes --ref=ci/snapshot-updates append -F snapshot-update-note.txt ${{ github.sha }}
          fi

          # Push to remote
          if git push origin refs/notes/ci/snapshot-updates --force 2>&1; then
            echo "‚úÖ Snapshot update metadata pushed to git notes"
          else
            echo "‚ùå ERROR: Failed to push snapshot update metadata notes"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}