name: Update Visual Snapshots

# This workflow updates visual regression test snapshots in the remote CI environment.
# Visual tests should NEVER be updated locally due to rendering inconsistencies.
#
# Trigger methods:
# 1. Manual: Go to Actions tab ‚Üí "Update Visual Snapshots" ‚Üí Run workflow
# 2. PR Comment: Comment "/update-snapshots" on a pull request
# 3. Commit Footer: Add "Snapshots: update" footer to commit message

on:
  # Manual trigger from GitHub UI
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to update snapshots on'
        required: false
        default: ''

  # Trigger via PR comment
  issue_comment:
    types: [created]

  # Trigger via commit footer containing "Snapshots: update"
  push:
    branches:
      - '**'

# Prevent simultaneous snapshot update runs on the same branch
# Queue new runs to ensure all updates complete without conflicts
concurrency:
  group: update-snapshots-${{ github.ref }}
  cancel-in-progress: false

# Sets permissions of the GITHUB_TOKEN to allow pushing commits and git notes
permissions:
  contents: write

jobs:
  # Check if workflow should run
  check-trigger:
    name: Check Trigger Condition
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      branch: ${{ steps.check.outputs.branch }}
    steps:
      - name: Checkout code (for scripts)
        uses: actions/checkout@v4

      - name: Check trigger condition
        id: check
        run: ./.github/scripts/snapshots/check-trigger.sh

  # Update snapshots
  update-snapshots:
    name: Update Snapshots in CI
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'
    timeout-minutes: 30
    outputs:
      checkout_success: ${{ steps.record_checkout.outputs.success }}
      docker_success: ${{ steps.record_docker.outputs.success }}
      playwright_success: ${{ steps.record_playwright.outputs.success }}
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
      files_changed: ${{ steps.check_changes.outputs.files_count }}
      commit_success: ${{ steps.record_commit.outputs.success }}
      push_success: ${{ steps.record_push.outputs.success }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.check-trigger.outputs.branch }}
          # Need write access to push changes
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Record checkout success
        id: record_checkout
        run: echo "success=true" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Record Docker setup success
        id: record_docker
        run: echo "success=true" >> $GITHUB_OUTPUT

      - name: Cleanup existing Docker resources
        run: ./.github/scripts/docker/cleanup-resources.sh docker-compose.e2e.yml

      - name: Run visual tests with snapshot update
        id: record_playwright
        timeout-minutes: 15  # Prevent indefinite hangs (Playwright tests should complete < 10 min)
        run: |
          TEST_SCOPE="${{ needs.check-trigger.outputs.test_scope }}"
          echo "üì∏ Updating visual snapshots in remote CI environment..."
          echo "‚ÑπÔ∏è  Test scope: $TEST_SCOPE"

          # Build Playwright test pattern based on scope
          case "$TEST_SCOPE" in
            visual)
              TEST_PATTERN="tests/visual/"
              echo "   Running only visual tests (tests/visual/)"
              ;;
            e2e)
              TEST_PATTERN="tests/e2e/"
              echo "   Running only e2e tests (tests/e2e/)"
              ;;
            all|*)
              TEST_PATTERN=""  # Empty = all tests
              echo "   Running all visual tests (tests/visual/ and tests/e2e/)"
              ;;
          esac

          # Pass test pattern to Playwright via environment variable
          export PLAYWRIGHT_TEST_PATTERN="$TEST_PATTERN"
          PLAYWRIGHT_ARGS="--update-snapshots" docker compose -f docker-compose.e2e.yml up --build --abort-on-container-exit
          echo "success=true" >> $GITHUB_OUTPUT
        env:
          DOCKER_USER: root
          TEST_ENV: ci-docker
          UPDATING_SNAPSHOTS: true

      - name: Check for snapshot changes
        id: check_changes
        run: |
          if git diff --quiet packages/frontend/tests; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "files_count=0" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No snapshot changes detected"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            CHANGED_COUNT=$(git diff --name-only packages/frontend/tests | wc -l | xargs)
            echo "files_count=${CHANGED_COUNT}" >> $GITHUB_OUTPUT
            echo "‚úÖ Snapshot changes detected (${CHANGED_COUNT} files)"
          fi

      - name: Configure git for bot
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: ./.github/actions/configure-git-bot

      - name: Commit and push snapshot updates
        id: record_commit
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git add packages/frontend/tests

          # Create descriptive commit message
          CHANGED_FILES=$(git diff --cached --name-only | wc -l)
          git commit -m "test(frontend): Update visual snapshots in CI [skip ci]

          Updated $CHANGED_FILES snapshot file(s) in remote CI environment.

          This ensures pixel-perfect consistency with the CI/CD pipeline.
          Visual snapshots should only be generated in the remote environment
          to avoid platform-specific rendering differences.

          ü§ñ Generated by GitHub Actions
          Workflow: ${{ github.workflow }}
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "success=true" >> $GITHUB_OUTPUT

      - name: Push snapshot updates
        id: record_push
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git push
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Comment on PR (if triggered by PR comment)
        if: github.event_name == 'issue_comment' && steps.check_changes.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚úÖ Visual snapshots have been updated in the remote CI environment and committed to this branch.\n\nPlease review the changes before merging.'
            })

      - name: Upload Playwright HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-snapshots
          path: packages/frontend/playwright-report/
          retention-days: 7

      - name: Upload visual test artifacts (failed + passed)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: visual-test-artifacts
          path: |
            packages/frontend/test-results/**/test-failed-*.png
            packages/frontend/test-results/**/diff-*.png
            packages/frontend/test-results/**/*-actual.png
            packages/frontend/test-results/**/*-expected.png
            packages/frontend/test-results/**/error-context.md
            packages/frontend/tests/**/ui-snapshots.spec.ts-snapshots/*.png
          retention-days: 7

      - name: Summary
        run: |
          if [ "${{ steps.check_changes.outputs.has_changes }}" = "true" ]; then
            echo "### ‚úÖ Snapshots Updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Visual regression snapshots have been updated in the remote CI environment." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Changed files:** $(git diff HEAD~1 --name-only packages/frontend/tests | wc -l)" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ÑπÔ∏è No Changes" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No visual snapshot updates were needed." >> $GITHUB_STEP_SUMMARY
          fi

  # Capture workflow metadata in git notes (post-job)
  capture-metadata:
    name: Capture Workflow Metadata
    runs-on: ubuntu-latest
    needs: [check-trigger, update-snapshots]
    if: always() && needs.check-trigger.outputs.should_run == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Capture metadata in git notes
        run: |
          # Use needs context to get accurate final status
          WORKFLOW_STATUS="${{ needs.update-snapshots.result }}"  # success, failure, cancelled, skipped
          CHECKOUT_SUCCESS="${{ needs.update-snapshots.outputs.checkout_success || 'false' }}"
          DOCKER_SUCCESS="${{ needs.update-snapshots.outputs.docker_success || 'false' }}"
          PLAYWRIGHT_SUCCESS="${{ needs.update-snapshots.outputs.playwright_success || 'false' }}"
          HAS_CHANGES="${{ needs.update-snapshots.outputs.has_changes || 'false' }}"
          CHANGED_FILES_COUNT="${{ needs.update-snapshots.outputs.files_changed || '0' }}"
          COMMIT_SUCCESS="${{ needs.update-snapshots.outputs.commit_success || 'false' }}"
          PUSH_SUCCESS="${{ needs.update-snapshots.outputs.push_success || 'false' }}"
          TRIGGER_METHOD="${{ github.event_name }}"

          # Export for extraction script
          export WORKFLOW_STATUS
          export CHECKOUT_SUCCESS
          export DOCKER_SUCCESS
          export PLAYWRIGHT_SUCCESS
          export HAS_CHANGES
          export CHANGED_FILES_COUNT
          export COMMIT_SUCCESS
          export PUSH_SUCCESS
          export TRIGGER_METHOD

          # Extract metadata
          ./.github/scripts/extract-snapshot-update-metadata.sh snapshot-update-note.txt

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch existing notes (may not exist yet)
          git fetch origin refs/notes/ci/snapshot-updates:refs/notes/ci/snapshot-updates 2>/dev/null || \
            echo "‚ÑπÔ∏è No existing notes found (first run)"

          # Add note to current commit
          if git notes --ref=ci/snapshot-updates add -F snapshot-update-note.txt ${{ github.sha }} 2>/dev/null; then
            echo "‚úÖ Snapshot update metadata note created"
          else
            # Note already exists, append instead
            echo "‚ÑπÔ∏è Note already exists, updating..."
            git notes --ref=ci/snapshot-updates append -F snapshot-update-note.txt ${{ github.sha }}
          fi

          # Push to remote
          if git push origin refs/notes/ci/snapshot-updates --force 2>&1; then
            echo "‚úÖ Snapshot update metadata pushed to git notes"
          else
            echo "‚ùå ERROR: Failed to push snapshot update metadata notes"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}