name: CI

# CI runs on code changes but skips documentation-only commits for efficiency.
#
# âœ… CI RUNS when changes include:
#   - packages/** (frontend, backend, infra code)
#   - package.json, tsconfig*.json (root configs)
#   - .prettierrc*, .eslintrc* (code quality tools)
#   - .github/workflows/ci.yml (this workflow)
#   - .github/actions/** (custom actions)
#   - docker-compose.e2e.yml, Dockerfile* (E2E test configs)
#
# â­ï¸  CI SKIPS when ONLY these files change:
#   - **.md (README, CLAUDE.md, documentation)
#   - .claude/** (Claude Code skills, settings)
#   - .github/workflows/*.yml (other workflows)
#   - LICENSE, .gitignore, .gitattributes
#
on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'                    # Documentation files
      - '.claude/**'               # Claude Code skills and settings
      - '.github/workflows/*.yml'  # Other workflows
      - '!.github/workflows/ci.yml' # Except this workflow itself
      - 'LICENSE'
      - '.gitignore'
      - '.gitattributes'
  pull_request:
    branches: [main]
    paths-ignore:
      - '**.md'                    # Documentation files
      - '.claude/**'               # Claude Code skills and settings
      - '.github/workflows/*.yml'  # Other workflows
      - '!.github/workflows/ci.yml' # Except this workflow itself
      - 'LICENSE'
      - '.gitignore'
      - '.gitattributes'

# Prevent simultaneous workflow runs on the same branch
# Queue new runs to ensure all commits are validated
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write  # Required to push git notes (Docker cache metrics)

jobs:
  # Job 1a: Code formatting check (parallel with lint and type-check)
  code-format:
    name: Code Formatting
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup project
        uses: ./.github/actions/setup-node-project
        with:
          node-version: '24'

      - name: Check formatting
        run: npm run format:check

  # Job 1b: Linting (parallel with format and type-check)
  lint:
    name: Lint
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup project
        uses: ./.github/actions/setup-node-project
        with:
          node-version: '24'

      - name: Run linters
        run: npm run lint

  # Job 1c: Type checking (parallel with format and lint)
  type-check:
    name: Type Check
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup project
        uses: ./.github/actions/setup-node-project
        with:
          node-version: '24'

      - name: Type check frontend
        run: npm run type-check --workspace=frontend

  # Job 2: Build all packages
  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup project
        uses: ./.github/actions/setup-node-project
        with:
          node-version: '24'

      - name: Build all packages
        run: npm run build 2>&1 | tee build-log.txt
        continue-on-error: true
        id: build

      - name: Check build status
        if: steps.build.outcome == 'failure'
        run: |
          echo "âŒ Build failed - logs captured in build-log.txt"
          exit 1

      - name: Upload build log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build-log.txt
          retention-days: 30

  # Job 3: Build and cache Docker base images
  docker-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build]  # Run after TypeScript build succeeds

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and cache backend-e2e image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          target: backend-e2e
          push: false
          load: true
          tags: trip-settle-backend:ci
          cache-from: type=gha,scope=backend-e2e
          cache-to: type=gha,mode=max,scope=backend-e2e

      - name: Build and cache frontend-dev image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          target: frontend-dev
          push: false
          load: true
          tags: trip-settle-frontend:ci
          cache-from: type=gha,scope=frontend-dev
          cache-to: type=gha,mode=max,scope=frontend-dev

      - name: Save backend image
        run: docker save trip-settle-backend:ci -o /tmp/backend-image.tar

      - name: Save frontend image
        run: docker save trip-settle-frontend:ci -o /tmp/frontend-image.tar

      - name: Upload backend image artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-image
          path: /tmp/backend-image.tar
          retention-days: 1

      - name: Upload frontend image artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-image
          path: /tmp/frontend-image.tar
          retention-days: 1

      - name: Capture backend and frontend build metrics
        if: always()
        run: ./.github/scripts/docker/capture-cache-metrics.sh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 4: Unit tests
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10

    strategy:
      matrix:
        package: [backend, frontend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup project
        uses: ./.github/actions/setup-node-project
        with:
          node-version: '24'

      - name: Run ${{ matrix.package }} tests
        run: |
          if [ "${{ matrix.package }}" = "frontend" ]; then
            npm run test:unit --workspace=frontend
          else
            npm run test --workspace=${{ matrix.package }} -- --passWithNoTests
          fi

  # Job 5: E2E tests with Docker
  e2e-tests:
    name: E2E Tests (Docker)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [docker-images]  # Run after Docker images are built
    # Prevent multiple E2E test runs from conflicting
    concurrency:
      group: e2e-tests-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download backend image
        uses: actions/download-artifact@v4
        with:
          name: backend-image
          path: /tmp

      - name: Download frontend image
        uses: actions/download-artifact@v4
        with:
          name: frontend-image
          path: /tmp

      - name: Load pre-built images
        run: |
          echo "ðŸ“¦ Loading pre-built Docker images..."
          docker load -i /tmp/backend-image.tar
          docker load -i /tmp/frontend-image.tar
          echo "âœ… Images loaded successfully"
          docker images | grep trip-settle

      - name: Cache Playwright base image
        id: cache-playwright-image
        uses: actions/cache@v4
        with:
          path: /tmp/playwright-image.tar
          key: playwright-base-image-v1.56.1-noble-${{ hashFiles('packages/frontend/Dockerfile.e2e') }}
          restore-keys: |
            playwright-base-image-v1.56.1-noble-

      - name: Diagnose cache status
        run: |
          echo "=== CACHE DIAGNOSTIC INFORMATION ==="
          echo "Cache hit: ${{ steps.cache-playwright-image.outputs.cache-hit }}"
          echo "Cache primary key: ${{ steps.cache-playwright-image.outputs.cache-primary-key }}"
          echo "Cache matched key: ${{ steps.cache-playwright-image.outputs.cache-matched-key }}"
          echo "Dockerfile hash: ${{ hashFiles('packages/frontend/Dockerfile.e2e') }}"
          echo ""
          echo "Tar file check:"
          if [ -f /tmp/playwright-image.tar ]; then
            ls -lh /tmp/playwright-image.tar
            echo "âœ… Tar file exists (restored from cache)"
          else
            echo "âŒ Tar file does not exist (cache miss - will pull and save)"
          fi
          echo "==================================="

      - name: Load or pull Playwright base image
        run: ./.github/scripts/docker/load-playwright-image.sh /tmp/playwright-image.tar mcr.microsoft.com/playwright:v1.56.1-noble

      - name: Cleanup any existing Docker resources
        run: ./.github/scripts/docker/cleanup-resources.sh docker-compose.e2e.yml

      - name: Build Playwright test image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./packages/frontend/Dockerfile.e2e
          push: false
          load: true
          tags: trip-settle-playwright:ci
          cache-from: type=gha,scope=playwright-e2e
          cache-to: type=gha,mode=max,scope=playwright-e2e
          outputs: type=docker
        # Capture build output for cache metrics analysis
        # Note: docker/build-push-action doesn't support output redirection
        # Build summary is automatically generated by the action

      - name: Append Playwright build metrics
        if: always()  # Run even if build or tests fail
        run: |
          ./.github/scripts/docker/append-playwright-metrics.sh \
            "${{ github.sha }}" \
            "${{ steps.cache-playwright-image.outputs.cache-hit }}" \
            "${DOCKER_LOAD_DURATION:-0}"
        env:
          DOCKERFILE_HASH: ${{ hashFiles('packages/frontend/Dockerfile.e2e') }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run E2E tests with pre-built images
        run: |
          # Use pre-built images in docker-compose
          BACKEND_IMAGE=trip-settle-backend:ci \
          BACKEND_TARGET=backend-e2e \
          FRONTEND_IMAGE=trip-settle-frontend:ci \
          PLAYWRIGHT_IMAGE=trip-settle-playwright:ci \
          docker compose -f docker-compose.e2e.yml up --abort-on-container-exit
        env:
          DOCKER_USER: root  # Run as root in CI to avoid permission issues with bind mounts

      - name: Upload Playwright report
        if: always()  # Upload report even if tests fail
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: packages/frontend/playwright-report/
          retention-days: 30

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-test-results
          path: packages/frontend/test-results/
          retention-days: 30

      - name: Extract E2E test failure metadata
        if: always() && hashFiles('packages/frontend/test-results/results.json') != ''
        id: extract-failures
        uses: ./.github/actions/extract-e2e-failures
        with:
          results-path: packages/frontend/test-results/results.json
          output-path: e2e-failure-note.txt

      - name: Store failure metadata in git notes
        if: always() && steps.extract-failures.conclusion == 'success'
        run: |
          echo "ðŸ“Š Storing E2E failure metadata in git notes..."

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch existing notes (may not exist yet)
          git fetch origin refs/notes/ci/e2e-failures:refs/notes/ci/e2e-failures 2>/dev/null || \
            echo "â„¹ï¸ No existing notes found (first run)"

          # Add note to current commit
          if git notes --ref=ci/e2e-failures add -F e2e-failure-note.txt ${{ github.sha }} 2>/dev/null; then
            echo "âœ… E2E failure metadata note created"
          else
            # Note already exists, append instead
            echo "â„¹ï¸ Note already exists, updating..."
            git notes --ref=ci/e2e-failures append -F e2e-failure-note.txt ${{ github.sha }}
          fi

          # Push to remote
          if git push origin refs/notes/ci/e2e-failures --force 2>&1; then
            echo "âœ… E2E failure metadata pushed to git notes"
          else
            echo "âŒ ERROR: Failed to push E2E failure metadata notes"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify cache will be saved
        if: always()
        run: ./.github/scripts/docker/verify-cache.sh /tmp/playwright-image.tar "${{ hashFiles('packages/frontend/Dockerfile.e2e') }}"

      - name: Clean up Docker resources
        if: always()
        run: docker compose -f docker-compose.e2e.yml down -v --remove-orphans

  # Job 6: All checks passed
  all-checks:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [code-format, lint, type-check, build, unit-tests, e2e-tests]
    if: always()

    steps:
      - name: Checkout code
        if: contains(needs.*.result, 'failure')
        uses: actions/checkout@v4

      - name: Setup Node.js
        if: contains(needs.*.result, 'failure')
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Download build log artifact
        if: contains(needs.*.result, 'failure')
        uses: actions/download-artifact@v4
        with:
          name: build-log
          path: .
        continue-on-error: true  # May not exist if build didn't fail

      - name: Generate failure report
        if: contains(needs.*.result, 'failure')
        uses: ./.github/actions/generate-failure-report
        with:
          build-log-path: build-log.txt
          output-path: ci-failure-report.md

      - name: Add report to job summary
        if: contains(needs.*.result, 'failure') && hashFiles('ci-failure-report.md') != ''
        run: cat ci-failure-report.md >> $GITHUB_STEP_SUMMARY

      - name: Upload failure report
        if: contains(needs.*.result, 'failure') && hashFiles('ci-failure-report.md') != ''
        uses: actions/upload-artifact@v4
        with:
          name: ci-failure-report
          path: ci-failure-report.md
          retention-days: 30

      - name: Check if all jobs succeeded
        run: |
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "âŒ One or more checks failed"
            echo "ðŸ“„ Download the ci-failure-report artifact for detailed analysis"
            exit 1
          elif [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            echo "âš ï¸ One or more checks were cancelled"
            exit 1
          else
            echo "âœ… All checks passed!"
          fi

  # Capture workflow timing metrics for performance analysis
  capture-workflow-metrics:
    name: Capture Workflow Metrics
    runs-on: ubuntu-latest
    if: always()
    needs: [build-and-test, docker-e2e-test, infrastructure-validation, all-checks]
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch workflow metrics git notes
        run: |
          git fetch origin refs/notes/ci/workflow-metrics:refs/notes/ci/workflow-metrics || echo "No existing workflow metrics notes"

      - name: Fetch workflow run data
        id: fetch-metrics
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch workflow run details including job timing
          gh api /repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs \
            --jq '.jobs[] | {name: .name, status: .status, conclusion: .conclusion, started_at: .started_at, completed_at: .completed_at, steps: [.steps[] | {name: .name, status: .status, conclusion: .conclusion, started_at: .started_at, completed_at: .completed_at}]}' \
            > workflow-jobs.json

          # Display for debugging
          cat workflow-jobs.json

      - name: Parse and store metrics
        run: |
          # Calculate job durations and format as git note
          python3 << 'EOF'
          import json
          from datetime import datetime

          # Read workflow jobs data
          with open('workflow-jobs.json', 'r') as f:
              lines = f.readlines()

          jobs = [json.loads(line) for line in lines if line.strip()]

          # Parse timestamps and calculate durations
          def parse_duration(started, completed):
              if not started or not completed:
                  return None
              start = datetime.fromisoformat(started.replace('Z', '+00:00'))
              end = datetime.fromisoformat(completed.replace('Z', '+00:00'))
              return int((end - start).total_seconds())

          # Create git note in INI format
          note_lines = []
          note_lines.append("[workflow]")
          note_lines.append(f"run_id = ${{ github.run_id }}")
          note_lines.append(f"run_number = ${{ github.run_number }}")
          note_lines.append(f"workflow = ${{ github.workflow }}")
          note_lines.append(f"event = ${{ github.event_name }}")
          note_lines.append(f"ref = ${{ github.ref }}")
          note_lines.append(f"sha = ${{ github.sha }}")
          note_lines.append(f"actor = ${{ github.actor }}")
          note_lines.append("")

          # Add job metrics
          for idx, job in enumerate(jobs, 1):
              note_lines.append(f"[job.{idx}]")
              note_lines.append(f"name = {job['name']}")
              note_lines.append(f"status = {job['status']}")
              note_lines.append(f"conclusion = {job['conclusion']}")

              duration = parse_duration(job.get('started_at'), job.get('completed_at'))
              if duration:
                  note_lines.append(f"duration_seconds = {duration}")

              note_lines.append("")

              # Add step metrics
              steps = job.get('steps', [])
              for step_idx, step in enumerate(steps, 1):
                  note_lines.append(f"[job.{idx}.step.{step_idx}]")
                  note_lines.append(f"name = {step['name']}")
                  note_lines.append(f"status = {step['status']}")
                  note_lines.append(f"conclusion = {step['conclusion']}")

                  step_duration = parse_duration(step.get('started_at'), step.get('completed_at'))
                  if step_duration:
                      note_lines.append(f"duration_seconds = {step_duration}")

                  note_lines.append("")

          # Write to file
          with open('workflow-metrics.ini', 'w') as f:
              f.write('\n'.join(note_lines))

          print("âœ… Workflow metrics captured successfully")
          EOF

      - name: Store metrics in git notes
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add note to current commit
          git notes --ref=ci/workflow-metrics add -F workflow-metrics.ini ${{ github.sha }} || \
            git notes --ref=ci/workflow-metrics append -F workflow-metrics.ini ${{ github.sha }}

          # Push notes to remote
          git push origin refs/notes/ci/workflow-metrics

          echo "âœ… Workflow metrics stored in git notes (refs/notes/ci/workflow-metrics)"
